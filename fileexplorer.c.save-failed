#include <windows.h> /* for HANDLE type, and console functions */
#include <stdio.h> /* standard input/output */
#include <stdlib.h> /* included for rand */
#include <string.h>

//For directory
#include <dirent.h> //needed for the struct dirent
#include <sys/stat.h> //To determine the size of a file.

#include "def.h"
#include "fileexplorer.h"

/**
useful link :
https://theasciicode.com.ar/extended-ascii-code/block-graphic-character-ascii-code-219.html
https://www.fosslinux.com/7413/5-best-linux-console-file-managers.htm
https://codeforwin.org/2018/03/c-program-to-list-all-files-in-a-directory-recursively.html
**/

bool runExplorer = true;

int selectLine = 0;
int maxLine = 0;
bool pressedEnter = false;
int scroll = 0;
char workingDir[1000];
char returnPath[1000];

//PopupWindows
struct validpop element;

char *explore()
{

    int x, y;
    getcwd(workingDir, sizeof(workingDir));
    resetScreen();

    element.select = 0;


    while(runExplorer)
    {

        if(element.Active)
        {
        popup(element.filePath,element.select);
        }
        else
        {
            resetLeft();
            initBorders();
            tree(workingDir,0);
        }

        screen();



        print("Appuyer sur 'Entrer' pour selectionner",2,HEIGHT-1,112);

        if (_kbhit())
        {
            char str[20];
            int value = getch();

            //If normal
            if(!element.Active)
            {

                switch(value) {
            case 72:
                if(scroll == selectLine && scroll>0)
                {
                    scroll--;
                    selectLine--;
                }
                else if(selectLine != -1)
                {
                selectLine--;
                }

                break;
            case 80:

                if(selectLine == HEIGHT - 6 + scroll && selectLine<(maxLine-1))
                {
                    scroll++;
                    selectLine++;
                }
                else if(selectLine<(maxLine-1))
                {
                   selectLine++;
                }

                break;
            case 13: //pressed enter
                pressedEnter = true;

                if(pressedEnter && selectLine == -1 && scroll ==0)
                {
                    strcat(workingDir,"/..");
                    pressedEnter = false;
                }

                break;
            case 27: //escape key
                runExplorer = false;
                system("CLS");
                printf("Program end");
                exit(0);
                break;
                }



            }
            else
            {

                if(value ==77 || value ==75)
                {
                   if(element.select == 1)
                    {
                        element.select =0;
                    }
                    else
                    {
                        element.select = 1;
                    }
                }

                if(value == 27)
                {
                    resetScreen();
                    element.Active = false;
                }


            }
        }


    }


    return &returnPath[0];

}




void tree(char *basePath, const int root)
{
    int i,line = 0;;
    char path[1000];
    struct dirent *dp;
    DIR *dir = opendir(basePath);

    print((*dir).dd_name,2,0,112);



    if(selectLine == -1)
    {
    print("../",3,2,158);
    }
    else if(scroll == 0)
    {
    print("../",3,2,241);
    }


    if (!dir)
        return;

    while ((dp = readdir(dir)) != NULL)
    {
        if(line>=scroll)
        {

        if (strcmp(dp->d_name, ".") != 0 && strcmp(dp->d_name, "..") != 0)
        {

            strcpy(path, basePath);
            strcat(path, "/");
            strcat(path, dp->d_name);




            if(opendir(path))
            {

                if(pressedEnter && selectLine == line)
                {
                    workingDir[0] = '\0';
                    selectLine = 0;
                    strcat(workingDir,path);
                    pressedEnter = false;
                    closedir(dir);
                    return;
                }



                if(line < HEIGHT - 4 + scroll)
                {

                    if(selectLine == line)
                    {
                        print(append_(dp->d_name,'/'),3,3+line-scroll,158);
                    }
                    else
                    {
                        print(append_(dp->d_name,'/'),3,3+line-scroll,241);
                    }

                line++;
                }
            }
            else
            {

                if(pressedEnter && selectLine == line && !element.Active)
                {
                    returnPath[0] = '\0';
                    strcat(returnPath,path);

                    pressedEnter = false;
                    char str[100];
                    sprintf(str, "Scanner le fichier %s", dp->d_name);

                    element.filePath = &str[0];
                    element.Active = true;


                }


                if(line < HEIGHT - 4 + scroll)
                {
                    if(selectLine == line)
                    {
                print(dp->d_name,3,3+line-scroll,158);
                    }
                    else
                    {
               print(dp->d_name,3,3+line-scroll,246);
                    }


                int i = fsize(path);
                char str[20];

                if(i > 100000000000)
                {
                    i = i/100000000000;
                    sprintf(str, "%d To", i);
                }
                else if(i > 100000000)
                {
                    i = i/100000000;
                    sprintf(str, "%d Go", i);
                }
                else if(i > 1000000)
                {
                    i = i/1000000;
                    sprintf(str, "%d Mo", i);
                }
                else if(i>1000)
                {
                    i = i/1000;
                    sprintf(str, "%d Ko", i);
                }
                else
                {
                    sprintf(str, "%d O", i);
                }


                    print(str,WIDTH/2 - 2 - strlen(str),3+line-scroll,248);



                line++;
                }
            }


            //tree(path, root + 2);
        }
    }
    else
    {
        line++;
    }
    }

    maxLine = line;

    closedir(dir);
}

off_t fsize(const char *filename) {
    struct stat st;

    if (stat(filename, &st) == 0)
        return st.st_size;

    return -1;
}

char* append_(const char *s, char c)
{
    int len = strlen(s);
    char buf[len+2];
    strcpy(buf, s);
    buf[len] = c;
    buf[len + 1] = 0;
    return strdup(buf);
}
